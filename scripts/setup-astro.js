const fs = require("fs");
const path = require("path");

// Helper function to create directory if it doesn't exist
function ensureDirectoryExists(directory) {
  if (!fs.existsSync(directory)) {
    fs.mkdirSync(directory, { recursive: true });
  }
}

// Helper function to copy a file
function copyFile(source, target) {
  try {
    ensureDirectoryExists(path.dirname(target));
    fs.copyFileSync(source, target);
    console.log(`‚úì Created ${path.basename(target)}`);
  } catch (err) {
    console.error(`Error copying ${path.basename(source)}:`, err);
  }
}

// Create script file content
function createScriptContent(scriptType) {
  if (scriptType === "copy") {
    return `import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get the directory name for ES modules
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

function main() {
  try {
    // Define paths
    const projectRoot = process.cwd();
    const systemCssPath = path.join(projectRoot, "src", "nube-system", "styles", "system.css");
    const systemStylesPath = path.join(projectRoot, "src", "nube-system", "styles", "system-styles.css");

    // Read the system CSS file
    const systemCss = fs.readFileSync(systemCssPath, "utf8");

    // Create the header
    const header = \`/* 
This file is automatically generated from system.css
DO NOT EDIT DIRECTLY - Use the copy-css or purge-css scripts instead
Last copied: \${new Date().toISOString()}
Original size: \${systemCss.length} bytes
*/\`;

    // Write the file
    fs.writeFileSync(systemStylesPath, header + "\\n\\n" + systemCss);

    console.log("‚úÖ Successfully copied system.css to system-styles.css");
  } catch (error) {
    console.error("‚ùå Error while copying CSS:", error);
    process.exit(1);
  }
}

// Run the main function
main();`;
  } else if (scriptType === "purge") {
    return `import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import { globSync } from 'glob';

// Get the directory name for ES modules
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

function main() {
  try {
    // Define paths
    const projectRoot = process.cwd();
    const systemCssPath = path.join(projectRoot, "src", "nube-system", "styles", "system.css");
    const systemStylesPath = path.join(projectRoot, "src", "nube-system", "styles", "system-styles.css");

    // Read the system CSS file
    const systemCss = fs.readFileSync(systemCssPath, "utf8");

    // Get all project files
    const files = globSync("src/**/*.{astro,jsx,tsx,vue,svelte,html,js,ts}", {
      ignore: ["**/node_modules/**", "src/nube-system/**"]
    });

    // Read all project files
    const content = files.map(file => fs.readFileSync(file, "utf8")).join("\\n");

    // Extract all class names from content
    const usedClasses = new Set();
    
    // Match both class="..." and className="..." patterns
    const classRegex = /(?:class|className)=["']([^"']+)["']/g;
    let match;

    while ((match = classRegex.exec(content)) !== null) {
      match[1].split(/\\s+/).forEach(className => {
        if (className) usedClasses.add(className);
      });
    }

    console.log(\`Found \${usedClasses.size} unique class names in your project\`);

    // Better CSS parsing
    // First, keep comments, :root, and @-rules intact
    const cssAST = parseCss(systemCss);
    const purgedCss = filterCssRules(cssAST, usedClasses);
    
    // Create the header
    const header = \`/* 
This file is automatically generated from system.css
DO NOT EDIT DIRECTLY - Use the copy-css or purge-css scripts instead
Last purged: \${new Date().toISOString()}
Original size: \${systemCss.length} bytes
Purged size: \${purgedCss.length} bytes
Reduction: \${Math.round((1 - purgedCss.length / systemCss.length) * 100)}%
*/\`;

    // Write the purged CSS
    fs.writeFileSync(systemStylesPath, header + "\\n\\n" + purgedCss);

    console.log(\`‚úÖ Successfully purged CSS and saved to system-styles.css\`);
    console.log(
      \`üìâ Reduced file size by \${Math.round(
        (1 - purgedCss.length / systemCss.length) * 100
      )}%\`
    );
  } catch (error) {
    console.error("‚ùå Error while purging CSS:", error);
    console.error(error.stack);
    process.exit(1);
  }
}

// Simple CSS parser function
function parseCss(css) {
  const result = [];
  let currentRule = "";
  let braceLevel = 0;
  let inComment = false;
  let commentText = "";
  
  // Process the CSS character by character
  for (let i = 0; i < css.length; i++) {
    const char = css[i];
    
    // Handle comments
    if (char === '/' && css[i + 1] === '*' && !inComment) {
      inComment = true;
      commentText = '/*';
      i++; // Skip next character
      continue;
    }
    
    if (char === '*' && css[i + 1] === '/' && inComment) {
      inComment = false;
      commentText += '*/';
      result.push({ type: 'comment', content: commentText });
      commentText = "";
      i++; // Skip next character
      continue;
    }
    
    if (inComment) {
      commentText += char;
      continue;
    }
    
    // Build the current rule
    currentRule += char;
    
    // Track brace level for rule boundaries
    if (char === '{') {
      braceLevel++;
    } else if (char === '}') {
      braceLevel--;
      
      // When we've closed a top-level rule, add it to the result
      if (braceLevel === 0) {
        // Determine rule type
        const trimmed = currentRule.trim();
        
        if (trimmed.startsWith(':root')) {
          result.push({ type: 'root', content: currentRule });
        } else if (trimmed.startsWith('@media')) {
          result.push({ type: 'media', content: currentRule });
        } else {
          result.push({ type: 'rule', content: currentRule });
        }
        
        currentRule = "";
      }
    }
  }
  
  return result;
}

// Filter CSS rules based on used classes
function filterCssRules(cssAST, usedClasses) {
  let output = "";
  
  cssAST.forEach(node => {
    // Always keep comments and :root
    if (node.type === 'comment' || node.type === 'root') {
      output += node.content;
    }
    // For media queries, parse their contents separately
    else if (node.type === 'media') {
      const mediaMatch = node.content.match(/(@media[^{]+){(.*)}/s);
      if (mediaMatch) {
        const mediaQuery = mediaMatch[1];
        const mediaContent = mediaMatch[2];
        
        // Split media content into individual rules
        const mediaRules = [];
        let currentRule = "";
        let braceLevel = 0;
        
        for (let i = 0; i < mediaContent.length; i++) {
          const char = mediaContent[i];
          currentRule += char;
          
          if (char === '{') {
            braceLevel++;
          } else if (char === '}') {
            braceLevel--;
            
            if (braceLevel === 0) {
              mediaRules.push(currentRule);
              currentRule = "";
            }
          }
        }
        
        // Filter media rules
        const filteredMediaRules = mediaRules.filter(rule => {
          // Keep rules that contain used classes
          return Array.from(usedClasses).some(className => {
            // Extract selector from rule
            const selectorMatch = rule.match(/([^{]+){/);
            const selector = selectorMatch ? selectorMatch[1].trim() : "";
            
            // Check if the selector contains our class
            return (
              selector.includes(\`.\${className}\`) || 
              selector.includes(\`[class*=\${className}]\`) ||
              // Also match utility class patterns like xs_grid-x2 or md_fd1
              selector.includes(\`[class*=\${className.split('_')[0]}_\`) && 
              selector.includes(\`\${className.split('_')[1]}\`)
            );
          });
        });
        
        // If we have filtered rules, rebuild the media query
        if (filteredMediaRules.length > 0) {
          output += \`\${mediaQuery}{\${filteredMediaRules.join("")}}\`;
        }
      }
    }
    // For normal rules
    else if (node.type === 'rule') {
      const selectorMatch = node.content.match(/([^{]+){/);
      const selector = selectorMatch ? selectorMatch[1].trim() : "";
      
      // Check if any used class is in this selector
      const shouldKeep = Array.from(usedClasses).some(className => {
        return (
          selector.includes(\`.\${className}\`) || 
          selector.includes(\`[class*=\${className}]\`) ||
          // Match utility class patterns
          (className.includes('_') && 
           selector.includes(\`[class*=\${className.split('_')[0]}_\`) && 
           selector.includes(\`\${className.split('_')[1]}\`))
        );
      });
      
      if (shouldKeep) {
        output += node.content;
      }
    }
  });
  
  return output;
}

// Run the main function
main();`;
  }
}

// Main setup function
function setupAstro() {
  // Get the path to the installed package
  const packagePath = path.resolve(__dirname, "..");

  // Try to find the Astro project root (looking for src directory)
  let projectRoot = process.cwd();
  while (projectRoot !== "/" && !fs.existsSync(path.join(projectRoot, "src"))) {
    projectRoot = path.dirname(projectRoot);
  }

  // If we found an Astro project
  if (fs.existsSync(path.join(projectRoot, "src"))) {
    // Create nube-system directory structure
    const nubeSystemDir = path.join(projectRoot, "src", "nube-system");
    const scriptsDir = path.join(nubeSystemDir, "scripts");
    const stylesDir = path.join(nubeSystemDir, "styles");

    // Ensure directories exist
    ensureDirectoryExists(scriptsDir);
    ensureDirectoryExists(stylesDir);

    // Copy the system.css file
    const systemSource = path.join(packagePath, "styles", "system.css");
    const systemTarget = path.join(stylesDir, "system.css");
    copyFile(systemSource, systemTarget);

    // Create initial system-styles.css (copy of system.css)
    const systemStylesTarget = path.join(stylesDir, "system-styles.css");
    copyFile(systemSource, systemStylesTarget);

    // Create script files
    fs.writeFileSync(
      path.join(scriptsDir, "copy-css.js"),
      createScriptContent("copy")
    );
    fs.writeFileSync(
      path.join(scriptsDir, "purge-css.js"),
      createScriptContent("purge")
    );

    // Copy documentation
    const docSource = path.join(packagePath, "DOCUMENTATION.md");
    const docTarget = path.join(nubeSystemDir, "system.doc.md");
    copyFile(docSource, docTarget);

    // Update package.json scripts if it exists
    const packageJsonPath = path.join(projectRoot, "package.json");
    if (fs.existsSync(packageJsonPath)) {
      const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, "utf8"));
      packageJson.scripts = packageJson.scripts || {};
      packageJson.scripts["copy-css"] =
        "node --experimental-modules src/nube-system/scripts/copy-css.js";
      packageJson.scripts["purge-css"] =
        "node --experimental-modules src/nube-system/scripts/purge-css.js";
      fs.writeFileSync(packageJsonPath, JSON.stringify(packageJson, null, 2));
      console.log("‚úì Added scripts to package.json");
    }

    console.log("\nNube System has been set up in your project!");
    console.log("\nDirectory structure created:");
    console.log("src/");
    console.log("‚îî‚îÄ‚îÄ nube-system/");
    console.log("    ‚îú‚îÄ‚îÄ scripts/");
    console.log("    ‚îÇ   ‚îú‚îÄ‚îÄ copy-css.js");
    console.log("    ‚îÇ   ‚îî‚îÄ‚îÄ purge-css.js");
    console.log("    ‚îî‚îÄ‚îÄ styles/");
    console.log("        ‚îú‚îÄ‚îÄ system.css");
    console.log("        ‚îî‚îÄ‚îÄ system-styles.css");

    console.log("\nQuick Start:");
    console.log("\n// In your main layout or entry point:");
    console.log('import "../nube-system/styles/system-styles.css";');

    console.log("\nAvailable npm scripts:");
    console.log(
      "npm run copy-css  - Copy all utility classes to system-styles.css"
    );
    console.log(
      "npm run purge-css - Remove unused classes from system-styles.css"
    );

    console.log("\nCheck src/nube-system/system.doc.md for documentation.");
  }
}

// Run setup
setupAstro();
